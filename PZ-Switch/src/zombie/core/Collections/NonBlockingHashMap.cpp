#include "zombie/core/Collections/NonBlockingHashMap.h"

namespace zombie {
namespace core {
namespace Collections {

long NonBlockingHashMap::rawIndex(Object[] objects, int int0) {
 // TODO: Implement rawIndex
 return 0;
}

bool NonBlockingHashMap::CAS_kvs(Object[] objects0, Object[] objects1) {
 // TODO: Implement CAS_kvs
 return false;
}

int NonBlockingHashMap::hash(void *object) {
 // TODO: Implement hash
 return 0;
}

int NonBlockingHashMap::len(Object[] objects) {
 // TODO: Implement len
 return 0;
}

void *NonBlockingHashMap::key(Object[] objects, int int0) {
 // TODO: Implement key
 return nullptr;
}

void *NonBlockingHashMap::val(Object[] objects, int int0) {
 // TODO: Implement val
 return nullptr;
}

bool NonBlockingHashMap::CAS_key(Object[] objects, int int0, void *object0,
 void *object1) {
 // TODO: Implement CAS_key
 return false;
}

bool NonBlockingHashMap::CAS_val(Object[] objects, int int0, void *object0,
 void *object1) {
 // TODO: Implement CAS_val
 return false;
}

void NonBlockingHashMap::print() {
 // TODO: Implement print
}

void NonBlockingHashMap::print(Object[] objects0) {
 // TODO: Implement print
}

void NonBlockingHashMap::print2(Object[] objects0) {
 // TODO: Implement print2
}

long NonBlockingHashMap::reprobes() {
 // TODO: Implement reprobes
 return 0;
}

int NonBlockingHashMap::reprobe_limit(int int0) {
 // TODO: Implement reprobe_limit
 return 0;
}

public
NonBlockingHashMap::NonBlockingHashMap() {
 // TODO: Implement NonBlockingHashMap
 return nullptr;
}

public
NonBlockingHashMap::NonBlockingHashMap(int int0) {
 // TODO: Implement NonBlockingHashMap
 return nullptr;
}

void NonBlockingHashMap::initialize(int int0) {
 // TODO: Implement initialize
}

void NonBlockingHashMap::initialize() {
 // TODO: Implement initialize
}

int NonBlockingHashMap::size() {
 // TODO: Implement size
 return 0;
}

return NonBlockingHashMap::chm() {
 // TODO: Implement chm
 return nullptr;
}

bool NonBlockingHashMap::isEmpty() {
 // TODO: Implement isEmpty
 return false;
}

bool NonBlockingHashMap::containsKey(void *object) {
 // TODO: Implement containsKey
 return false;
}

bool NonBlockingHashMap::contains(void *object) {
 // TODO: Implement contains
 return false;
}

TypeV NonBlockingHashMap::put(TypeK object0, TypeV object1) {
 // TODO: Implement put
 return nullptr;
}

TypeV NonBlockingHashMap::putIfAbsent(TypeK object0, TypeV object1) {
 // TODO: Implement putIfAbsent
 return nullptr;
}

TypeV NonBlockingHashMap::remove(void *object) {
 // TODO: Implement remove
 return nullptr;
}

bool NonBlockingHashMap::remove(void *object1, void *object2) {
 // TODO: Implement remove
 return false;
}

TypeV NonBlockingHashMap::replace(TypeK object0, TypeV object1) {
 // TODO: Implement replace
 return nullptr;
}

bool NonBlockingHashMap::replace(TypeK object1, TypeV object3, TypeV object2) {
 // TODO: Implement replace
 return false;
}

TypeV NonBlockingHashMap::putIfMatch(void *object3, void *object0,
 void *object1) {
 // TODO: Implement putIfMatch
 return nullptr;
}

void NonBlockingHashMap::putAll(Map<? extends, ? extends) {
 // TODO: Implement putAll
}

void NonBlockingHashMap::clear() {
 // TODO: Implement clear
}

bool NonBlockingHashMap::containsValue(void *object0) {
 // TODO: Implement containsValue
 return false;
}

void NonBlockingHashMap::rehash() {
 // TODO: Implement rehash
}

void *NonBlockingHashMap::clone() {
 // TODO: Implement clone
 return nullptr;
}

std::string NonBlockingHashMap::toString() {
 // TODO: Implement toString
 return "";
}

bool NonBlockingHashMap::keyeq(void *object1, void *object0, int[] ints,
 int int1, int int0) {
 // TODO: Implement keyeq
 return false;
}

TypeV NonBlockingHashMap::get(void *object0) {
 // TODO: Implement get
 return nullptr;
}

void *NonBlockingHashMap::get_impl(NonBlockingHashMap nonBlockingHashMap,
 Object[] objects0, void *object2, int int2) {
 // TODO: Implement get_impl
 return nullptr;
}

return NonBlockingHashMap::get_impl() {
 // TODO: Implement get_impl
 return nullptr;
}

void *NonBlockingHashMap::putIfMatch(NonBlockingHashMap nonBlockingHashMap,
 Object[] objects0, void *object2,
 void *object0, void *object1) {
 // TODO: Implement putIfMatch
 return nullptr;
}

return NonBlockingHashMap::putIfMatch() {
 // TODO: Implement putIfMatch
 return nullptr;
}

return NonBlockingHashMap::putIfMatch() {
 // TODO: Implement putIfMatch
 return nullptr;
}

return NonBlockingHashMap::putIfMatch() {
 // TODO: Implement putIfMatch
 return nullptr;
}

void NonBlockingHashMap::clear() {
 // TODO: Implement clear
}

int NonBlockingHashMap::size() {
 // TODO: Implement size
 return 0;
}

bool NonBlockingHashMap::contains(void *object) {
 // TODO: Implement contains
 return false;
}

void NonBlockingHashMap::clear() {
 // TODO: Implement clear
}

int NonBlockingHashMap::size() {
 // TODO: Implement size
 return 0;
}

bool NonBlockingHashMap::contains(void *object) {
 // TODO: Implement contains
 return false;
}

bool NonBlockingHashMap::remove(void *object) {
 // TODO: Implement remove
 return false;
}

void NonBlockingHashMap::clear() {
 // TODO: Implement clear
}

int NonBlockingHashMap::size() {
 // TODO: Implement size
 return 0;
}

bool NonBlockingHashMap::remove(void *object) {
 // TODO: Implement remove
 return false;
}

bool NonBlockingHashMap::contains(void *object0) {
 // TODO: Implement contains
 return false;
}

void NonBlockingHashMap::writeObject(ObjectOutputStream objectOutputStream) {
 // TODO: Implement writeObject
}

void NonBlockingHashMap::readObject(ObjectInputStream objectInputStream) {
 // TODO: Implement readObject
}

int NonBlockingHashMap::size() {
 // TODO: Implement size
 return 0;
}

int NonBlockingHashMap::slots() {
 // TODO: Implement slots
 return 0;
}

bool NonBlockingHashMap::CAS_newkvs(Object[] objects) {
 // TODO: Implement CAS_newkvs
 return false;
}

bool NonBlockingHashMap::tableFull(int int1, int int0) {
 // TODO: Implement tableFull
 return false;
}

void NonBlockingHashMap::help_copy_impl(NonBlockingHashMap nonBlockingHashMap,
 Object[] objects0, bool boolean0) {
 // TODO: Implement help_copy_impl
}

void NonBlockingHashMap::copy_check_and_promote(
 NonBlockingHashMap nonBlockingHashMap, Object[] objects, int int1) {
 // TODO: Implement copy_check_and_promote
}

bool NonBlockingHashMap::copy_slot(NonBlockingHashMap nonBlockingHashMap,
 int int0, Object[] objects0,
 Object[] objects1) {
 // TODO: Implement copy_slot
 return false;
}

TypeV NonBlockingHashMap::setValue(TypeV object) {
 // TODO: Implement setValue
 return nullptr;
}

void *NonBlockingHashMap::unbox(void *object) {
 // TODO: Implement unbox
 return nullptr;
}

public
NonBlockingHashMap::SnapshotE() {
 // TODO: Implement SnapshotE
 return nullptr;
}

void NonBlockingHashMap::remove() {
 // TODO: Implement remove
}

bool NonBlockingHashMap::hasNext() {
 // TODO: Implement hasNext
 return false;
}

public
NonBlockingHashMap::SnapshotK() {
 // TODO: Implement SnapshotK
 return nullptr;
}

void NonBlockingHashMap::remove() {
 // TODO: Implement remove
}

TypeK NonBlockingHashMap::next() {
 // TODO: Implement next
 return nullptr;
}

bool NonBlockingHashMap::hasNext() {
 // TODO: Implement hasNext
 return false;
}

TypeK NonBlockingHashMap::nextElement() {
 // TODO: Implement nextElement
 return nullptr;
}

bool NonBlockingHashMap::hasMoreElements() {
 // TODO: Implement hasMoreElements
 return false;
}

public
NonBlockingHashMap::SnapshotV() {
 // TODO: Implement SnapshotV
 return nullptr;
}

int NonBlockingHashMap::length() {
 // TODO: Implement length
 return 0;
}

void *NonBlockingHashMap::key(int int0) {
 // TODO: Implement key
 return nullptr;
}

bool NonBlockingHashMap::hasNext() {
 // TODO: Implement hasNext
 return false;
}

TypeV NonBlockingHashMap::next() {
 // TODO: Implement next
 return nullptr;
}

void NonBlockingHashMap::remove() {
 // TODO: Implement remove
}

TypeV NonBlockingHashMap::nextElement() {
 // TODO: Implement nextElement
 return nullptr;
}

bool NonBlockingHashMap::hasMoreElements() {
 // TODO: Implement hasMoreElements
 return false;
}

} // namespace Collections
} // namespace core
} // namespace zombie
