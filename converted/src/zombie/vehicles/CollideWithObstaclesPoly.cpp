#include "zombie/vehicles/CollideWithObstaclesPoly.h"

namespace zombie {
namespace vehicles {

void CollideWithObstaclesPoly::getVehiclesInRect(float float0, float float1, float float2, float float3, int int7) {
 // TODO: Implement getVehiclesInRect
}

void CollideWithObstaclesPoly::getObstaclesInRect(float float3, float float1, float float2, float float0, int int4, int int5, int int8, bool boolean0) {
 // TODO: Implement getObstaclesInRect
}

Vector2f CollideWithObstaclesPoly::resolveCollision(IsoGameCharacter character, float float0, float float1, Vector2f vector2f) {
 // TODO: Implement resolveCollision
 return nullptr;
}

bool CollideWithObstaclesPoly::canStandAt(float float1, float float3, float float6, BaseVehicle vehicle, int int0) {
 // TODO: Implement canStandAt
 return false;
}

void CollideWithObstaclesPoly::vehicleMoved(PolygonalMap2.VehiclePoly vehiclePoly) {
 // TODO: Implement vehicleMoved
}

void CollideWithObstaclesPoly::vehicleMoved(PolygonalMap2.VehiclePoly vehiclePoly0, PolygonalMap2.VehiclePoly vehiclePoly1) {
 // TODO: Implement vehicleMoved
}

void CollideWithObstaclesPoly::render() {
 // TODO: Implement render
}

bool CollideWithObstaclesPoly::hasNode(CollideWithObstaclesPoly.CCNode cCNode) {
 // TODO: Implement hasNode
 return false;
}

void CollideWithObstaclesPoly::getClosestPointOnEdge(float float5, float float4, CollideWithObstaclesPoly.ClosestPointOnEdge closestPointOnEdge) {
 // TODO: Implement getClosestPointOnEdge
}

bool CollideWithObstaclesPoly::isPointOn(float float5, float float4) {
 // TODO: Implement isPointOn
 return false;
}

void CollideWithObstaclesPoly::release() {
 // TODO: Implement release
}

void CollideWithObstaclesPoly::releaseAll(ArrayList<CollideWithObstaclesPoly.CCEdge> arrayList) {
 // TODO: Implement releaseAll
}

void CollideWithObstaclesPoly::release(CollideWithObstaclesPoly.CCEdgeRing cCEdgeRing) {
 // TODO: Implement release
}

float CollideWithObstaclesPoly::isLeft(float float3, float float1, float float5, float float0, float float2, float float4) {
 // TODO: Implement isLeft
 return 0;
}

bool CollideWithObstaclesPoly::lineSegmentIntersects(float float3, float float1, float float2, float float0, bool boolean0, bool boolean1) {
 // TODO: Implement lineSegmentIntersects
 return false;
}

void CollideWithObstaclesPoly::getClosestPointOnEdge(float float0, float float1, CollideWithObstaclesPoly.ClosestPointOnEdge closestPointOnEdge) {
 // TODO: Implement getClosestPointOnEdge
}

void CollideWithObstaclesPoly::render(bool boolean0) {
 // TODO: Implement render
}

void CollideWithObstaclesPoly::releaseAll(ArrayList<CollideWithObstaclesPoly.CCEdgeRing> arrayList) {
 // TODO: Implement releaseAll
}

bool CollideWithObstaclesPoly::getNormalAndEdgeVectors(Vector2 vector0, Vector2 vector1) {
 // TODO: Implement getNormalAndEdgeVectors
 return false;
}

void CollideWithObstaclesPoly::release() {
 // TODO: Implement release
}

void CollideWithObstaclesPoly::releaseAll(ArrayList<CollideWithObstaclesPoly.CCNode> arrayList) {
 // TODO: Implement releaseAll
}

void CollideWithObstaclesPoly::release(CollideWithObstaclesPoly.CCObstacle cCObstacle) {
 // TODO: Implement release
}

bool CollideWithObstaclesPoly::isPointInside(float float0, float float1, int int0) {
 // TODO: Implement isPointInside
 return false;
}

bool CollideWithObstaclesPoly::lineSegmentIntersects(float float0, float float1, float float2, float float3, bool boolean0) {
 // TODO: Implement lineSegmentIntersects
 return false;
}

void CollideWithObstaclesPoly::getClosestPointOnEdge(float float0, float float1, CollideWithObstaclesPoly.ClosestPointOnEdge closestPointOnEdge) {
 // TODO: Implement getClosestPointOnEdge
}

void CollideWithObstaclesPoly::calcBounds() {
 // TODO: Implement calcBounds
}

void CollideWithObstaclesPoly::render() {
 // TODO: Implement render
}

void CollideWithObstaclesPoly::release() {
 // TODO: Implement release
}

void CollideWithObstaclesPoly::releaseAll(ArrayList<CollideWithObstaclesPoly.CCObstacle> arrayList) {
 // TODO: Implement releaseAll
}

void CollideWithObstaclesPoly::clearInner() {
 // TODO: Implement clearInner
}

void CollideWithObstaclesPoly::clear() {
 // TODO: Implement clear
}

void CollideWithObstaclesPoly::init(IsoChunk chunk, int int0, CollideWithObstaclesPoly collideWithObstaclesPoly) {
 // TODO: Implement init
}

void CollideWithObstaclesPoly::getEdgesFromBuffer(ByteBuffer byteBuffer, CollideWithObstaclesPoly.CCObstacle cCObstacle, bool boolean0) {
 // TODO: Implement getEdgesFromBuffer
}

void CollideWithObstaclesPoly::clipperToObstacles(Clipper clipper, ByteBuffer byteBuffer, ArrayList<CollideWithObstaclesPoly.CCObstacle> arrayList) {
 // TODO: Implement clipperToObstacles
}

bool CollideWithObstaclesPoly::isCollideW(int int0, int int1, int int2) {
 // TODO: Implement isCollideW
 return false;
}

bool CollideWithObstaclesPoly::isCollideN(int int0, int int1, int int2) {
 // TODO: Implement isCollideN
 return false;
}

bool CollideWithObstaclesPoly::isOpenDoorAt(int int0, int int1, int int2, bool boolean0) {
 // TODO: Implement isOpenDoorAt
 return false;
}

void CollideWithObstaclesPoly::clear() {
 // TODO: Implement clear
}

float CollideWithObstaclesPoly::left() {
 // TODO: Implement left
 return 0;
}

float CollideWithObstaclesPoly::top() {
 // TODO: Implement top
 return 0;
}

float CollideWithObstaclesPoly::right() {
 // TODO: Implement right
 return 0;
}

float CollideWithObstaclesPoly::bottom() {
 // TODO: Implement bottom
 return 0;
}

float CollideWithObstaclesPoly::width() {
 // TODO: Implement width
 return 0;
}

float CollideWithObstaclesPoly::height() {
 // TODO: Implement height
 return 0;
}

bool CollideWithObstaclesPoly::containsPoint(float float1, float float0) {
 // TODO: Implement containsPoint
 return false;
}

bool CollideWithObstaclesPoly::intersects(CollideWithObstaclesPoly.ImmutableRectF immutableRectF0) {
 // TODO: Implement intersects
 return false;
}

void CollideWithObstaclesPoly::release() {
 // TODO: Implement release
}

} // namespace vehicles
} // namespace zombie
