#include "zombie/core/Collections/NonBlockingIdentityHashMap.h"

namespace zombie {
namespace core {
namespace Collections {

long NonBlockingIdentityHashMap::rawIndex(Object[] objects, int int0) {
 // TODO: Implement rawIndex
 return 0;
}

bool NonBlockingIdentityHashMap::CAS_kvs(Object[] objects0, Object[] objects1) {
 // TODO: Implement CAS_kvs
 return false;
}

int NonBlockingIdentityHashMap::hash(void* object) {
 // TODO: Implement hash
 return 0;
}

int NonBlockingIdentityHashMap::len(Object[] objects) {
 // TODO: Implement len
 return 0;
}

void* NonBlockingIdentityHashMap::key(Object[] objects, int int0) {
 // TODO: Implement key
 return nullptr;
}

void* NonBlockingIdentityHashMap::val(Object[] objects, int int0) {
 // TODO: Implement val
 return nullptr;
}

bool NonBlockingIdentityHashMap::CAS_key(Object[] objects, int int0, void* object0, void* object1) {
 // TODO: Implement CAS_key
 return false;
}

bool NonBlockingIdentityHashMap::CAS_val(Object[] objects, int int0, void* object0, void* object1) {
 // TODO: Implement CAS_val
 return false;
}

void NonBlockingIdentityHashMap::print() {
 // TODO: Implement print
}

void NonBlockingIdentityHashMap::print(Object[] objects0) {
 // TODO: Implement print
}

void NonBlockingIdentityHashMap::print2(Object[] objects0) {
 // TODO: Implement print2
}

long NonBlockingIdentityHashMap::reprobes() {
 // TODO: Implement reprobes
 return 0;
}

int NonBlockingIdentityHashMap::reprobe_limit(int int0) {
 // TODO: Implement reprobe_limit
 return 0;
}

public NonBlockingIdentityHashMap::NonBlockingIdentityHashMap() {
 // TODO: Implement NonBlockingIdentityHashMap
 return nullptr;
}

public NonBlockingIdentityHashMap::NonBlockingIdentityHashMap(int int0) {
 // TODO: Implement NonBlockingIdentityHashMap
 return nullptr;
}

void NonBlockingIdentityHashMap::initialize(int int0) {
 // TODO: Implement initialize
}

void NonBlockingIdentityHashMap::initialize() {
 // TODO: Implement initialize
}

int NonBlockingIdentityHashMap::size() {
 // TODO: Implement size
 return 0;
}

return NonBlockingIdentityHashMap::chm() {
 // TODO: Implement chm
 return nullptr;
}

bool NonBlockingIdentityHashMap::isEmpty() {
 // TODO: Implement isEmpty
 return false;
}

bool NonBlockingIdentityHashMap::containsKey(void* object) {
 // TODO: Implement containsKey
 return false;
}

bool NonBlockingIdentityHashMap::contains(void* object) {
 // TODO: Implement contains
 return false;
}

TypeV NonBlockingIdentityHashMap::put(TypeK object0, TypeV object1) {
 // TODO: Implement put
 return nullptr;
}

TypeV NonBlockingIdentityHashMap::putIfAbsent(TypeK object0, TypeV object1) {
 // TODO: Implement putIfAbsent
 return nullptr;
}

TypeV NonBlockingIdentityHashMap::remove(void* object) {
 // TODO: Implement remove
 return nullptr;
}

bool NonBlockingIdentityHashMap::remove(void* object1, void* object0) {
 // TODO: Implement remove
 return false;
}

TypeV NonBlockingIdentityHashMap::replace(TypeK object0, TypeV object1) {
 // TODO: Implement replace
 return nullptr;
}

bool NonBlockingIdentityHashMap::replace(TypeK object1, TypeV object0, TypeV object2) {
 // TODO: Implement replace
 return false;
}

TypeV NonBlockingIdentityHashMap::putIfMatch(void* object3, void* object0, void* object1) {
 // TODO: Implement putIfMatch
 return nullptr;
}

void NonBlockingIdentityHashMap::putAll(Map<? extends, ? extends) {
 // TODO: Implement putAll
}

void NonBlockingIdentityHashMap::clear() {
 // TODO: Implement clear
}

bool NonBlockingIdentityHashMap::containsValue(void* object0) {
 // TODO: Implement containsValue
 return false;
}

void NonBlockingIdentityHashMap::rehash() {
 // TODO: Implement rehash
}

void* NonBlockingIdentityHashMap::clone() {
 // TODO: Implement clone
 return nullptr;
}

std::string NonBlockingIdentityHashMap::toString() {
 // TODO: Implement toString
 return "";
}

TypeV NonBlockingIdentityHashMap::get(void* object0) {
 // TODO: Implement get
 return nullptr;
}

void* NonBlockingIdentityHashMap::get_impl(NonBlockingIdentityHashMap nonBlockingIdentityHashMap, Object[] objects0, void* object2, int int2) {
 // TODO: Implement get_impl
 return nullptr;
}

return NonBlockingIdentityHashMap::get_impl() {
 // TODO: Implement get_impl
 return nullptr;
}

return NonBlockingIdentityHashMap::putIfMatch() {
 // TODO: Implement putIfMatch
 return nullptr;
}

void NonBlockingIdentityHashMap::clear() {
 // TODO: Implement clear
}

int NonBlockingIdentityHashMap::size() {
 // TODO: Implement size
 return 0;
}

bool NonBlockingIdentityHashMap::contains(void* object) {
 // TODO: Implement contains
 return false;
}

void NonBlockingIdentityHashMap::clear() {
 // TODO: Implement clear
}

int NonBlockingIdentityHashMap::size() {
 // TODO: Implement size
 return 0;
}

bool NonBlockingIdentityHashMap::contains(void* object) {
 // TODO: Implement contains
 return false;
}

bool NonBlockingIdentityHashMap::remove(void* object) {
 // TODO: Implement remove
 return false;
}

void NonBlockingIdentityHashMap::clear() {
 // TODO: Implement clear
}

int NonBlockingIdentityHashMap::size() {
 // TODO: Implement size
 return 0;
}

bool NonBlockingIdentityHashMap::remove(void* object) {
 // TODO: Implement remove
 return false;
}

bool NonBlockingIdentityHashMap::contains(void* object0) {
 // TODO: Implement contains
 return false;
}

void NonBlockingIdentityHashMap::writeObject(ObjectOutputStream objectOutputStream) {
 // TODO: Implement writeObject
}

void NonBlockingIdentityHashMap::readObject(ObjectInputStream objectInputStream) {
 // TODO: Implement readObject
}

int NonBlockingIdentityHashMap::size() {
 // TODO: Implement size
 return 0;
}

int NonBlockingIdentityHashMap::slots() {
 // TODO: Implement slots
 return 0;
}

bool NonBlockingIdentityHashMap::CAS_newkvs(Object[] objects) {
 // TODO: Implement CAS_newkvs
 return false;
}

bool NonBlockingIdentityHashMap::tableFull(int int1, int int0) {
 // TODO: Implement tableFull
 return false;
}

void NonBlockingIdentityHashMap::help_copy_impl(NonBlockingIdentityHashMap nonBlockingIdentityHashMap, Object[] objects0, bool boolean0) {
 // TODO: Implement help_copy_impl
}

void NonBlockingIdentityHashMap::copy_check_and_promote(NonBlockingIdentityHashMap nonBlockingIdentityHashMap, Object[] objects, int int1) {
 // TODO: Implement copy_check_and_promote
}

bool NonBlockingIdentityHashMap::copy_slot(NonBlockingIdentityHashMap nonBlockingIdentityHashMap, int int0, Object[] objects0, Object[] objects1) {
 // TODO: Implement copy_slot
 return false;
}

TypeV NonBlockingIdentityHashMap::setValue(TypeV object) {
 // TODO: Implement setValue
 return nullptr;
}

void* NonBlockingIdentityHashMap::unbox(void* object) {
 // TODO: Implement unbox
 return nullptr;
}

public NonBlockingIdentityHashMap::SnapshotE() {
 // TODO: Implement SnapshotE
 return nullptr;
}

void NonBlockingIdentityHashMap::remove() {
 // TODO: Implement remove
}

bool NonBlockingIdentityHashMap::hasNext() {
 // TODO: Implement hasNext
 return false;
}

public NonBlockingIdentityHashMap::SnapshotK() {
 // TODO: Implement SnapshotK
 return nullptr;
}

void NonBlockingIdentityHashMap::remove() {
 // TODO: Implement remove
}

TypeK NonBlockingIdentityHashMap::next() {
 // TODO: Implement next
 return nullptr;
}

bool NonBlockingIdentityHashMap::hasNext() {
 // TODO: Implement hasNext
 return false;
}

TypeK NonBlockingIdentityHashMap::nextElement() {
 // TODO: Implement nextElement
 return nullptr;
}

bool NonBlockingIdentityHashMap::hasMoreElements() {
 // TODO: Implement hasMoreElements
 return false;
}

public NonBlockingIdentityHashMap::SnapshotV() {
 // TODO: Implement SnapshotV
 return nullptr;
}

int NonBlockingIdentityHashMap::length() {
 // TODO: Implement length
 return 0;
}

void* NonBlockingIdentityHashMap::key(int int0) {
 // TODO: Implement key
 return nullptr;
}

bool NonBlockingIdentityHashMap::hasNext() {
 // TODO: Implement hasNext
 return false;
}

TypeV NonBlockingIdentityHashMap::next() {
 // TODO: Implement next
 return nullptr;
}

void NonBlockingIdentityHashMap::remove() {
 // TODO: Implement remove
}

TypeV NonBlockingIdentityHashMap::nextElement() {
 // TODO: Implement nextElement
 return nullptr;
}

bool NonBlockingIdentityHashMap::hasMoreElements() {
 // TODO: Implement hasMoreElements
 return false;
}

} // namespace Collections
} // namespace core
} // namespace zombie
