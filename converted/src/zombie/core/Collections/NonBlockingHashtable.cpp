#include "zombie/core/Collections/NonBlockingHashtable.h"

namespace zombie {
namespace core {
namespace Collections {

long NonBlockingHashtable::rawIndex(Object[] objects, int int0) {
 // TODO: Implement rawIndex
 return 0;
}

bool NonBlockingHashtable::CAS_kvs(Object[] objects0, Object[] objects1) {
 // TODO: Implement CAS_kvs
 return false;
}

int NonBlockingHashtable::hash(void* object) {
 // TODO: Implement hash
 return 0;
}

int NonBlockingHashtable::len(Object[] objects) {
 // TODO: Implement len
 return 0;
}

void* NonBlockingHashtable::key(Object[] objects, int int0) {
 // TODO: Implement key
 return nullptr;
}

void* NonBlockingHashtable::val(Object[] objects, int int0) {
 // TODO: Implement val
 return nullptr;
}

bool NonBlockingHashtable::CAS_key(Object[] objects, int int0, void* object0, void* object1) {
 // TODO: Implement CAS_key
 return false;
}

bool NonBlockingHashtable::CAS_val(Object[] objects, int int0, void* object0, void* object1) {
 // TODO: Implement CAS_val
 return false;
}

void NonBlockingHashtable::print() {
 // TODO: Implement print
}

void NonBlockingHashtable::print(Object[] objects0) {
 // TODO: Implement print
}

void NonBlockingHashtable::print2(Object[] objects0) {
 // TODO: Implement print2
}

long NonBlockingHashtable::reprobes() {
 // TODO: Implement reprobes
 return 0;
}

int NonBlockingHashtable::reprobe_limit(int int0) {
 // TODO: Implement reprobe_limit
 return 0;
}

public NonBlockingHashtable::NonBlockingHashtable() {
 // TODO: Implement NonBlockingHashtable
 return nullptr;
}

public NonBlockingHashtable::NonBlockingHashtable(int int0) {
 // TODO: Implement NonBlockingHashtable
 return nullptr;
}

void NonBlockingHashtable::initialize(int int0) {
 // TODO: Implement initialize
}

void NonBlockingHashtable::initialize() {
 // TODO: Implement initialize
}

int NonBlockingHashtable::size() {
 // TODO: Implement size
 return 0;
}

return NonBlockingHashtable::chm() {
 // TODO: Implement chm
 return nullptr;
}

bool NonBlockingHashtable::isEmpty() {
 // TODO: Implement isEmpty
 return false;
}

bool NonBlockingHashtable::containsKey(void* object) {
 // TODO: Implement containsKey
 return false;
}

bool NonBlockingHashtable::contains(void* object) {
 // TODO: Implement contains
 return false;
}

TypeV NonBlockingHashtable::put(TypeK object0, TypeV object1) {
 // TODO: Implement put
 return nullptr;
}

TypeV NonBlockingHashtable::putIfAbsent(TypeK object0, TypeV object1) {
 // TODO: Implement putIfAbsent
 return nullptr;
}

TypeV NonBlockingHashtable::remove(void* object) {
 // TODO: Implement remove
 return nullptr;
}

bool NonBlockingHashtable::remove(void* object1, void* object0) {
 // TODO: Implement remove
 return false;
}

TypeV NonBlockingHashtable::replace(TypeK object0, TypeV object1) {
 // TODO: Implement replace
 return nullptr;
}

bool NonBlockingHashtable::replace(TypeK object1, TypeV object0, TypeV object2) {
 // TODO: Implement replace
 return false;
}

TypeV NonBlockingHashtable::putIfMatch(void* object3, void* object0, void* object1) {
 // TODO: Implement putIfMatch
 return nullptr;
}

void NonBlockingHashtable::putAll(Map<? extends, ? extends) {
 // TODO: Implement putAll
}

void NonBlockingHashtable::clear() {
 // TODO: Implement clear
}

bool NonBlockingHashtable::containsValue(void* object0) {
 // TODO: Implement containsValue
 return false;
}

void NonBlockingHashtable::rehash() {
 // TODO: Implement rehash
}

void* NonBlockingHashtable::clone() {
 // TODO: Implement clone
 return nullptr;
}

std::string NonBlockingHashtable::toString() {
 // TODO: Implement toString
 return "";
}

bool NonBlockingHashtable::keyeq(void* object1, void* object0, int[] ints, int int1, int int0) {
 // TODO: Implement keyeq
 return false;
}

TypeV NonBlockingHashtable::get(void* object0) {
 // TODO: Implement get
 return nullptr;
}

void* NonBlockingHashtable::get_impl(NonBlockingHashtable nonBlockingHashtable, Object[] objects0, void* object2, int int2) {
 // TODO: Implement get_impl
 return nullptr;
}

return NonBlockingHashtable::get_impl() {
 // TODO: Implement get_impl
 return nullptr;
}

void* NonBlockingHashtable::putIfMatch(NonBlockingHashtable nonBlockingHashtable, Object[] objects0, void* object2, void* object0, void* object1) {
 // TODO: Implement putIfMatch
 return nullptr;
}

return NonBlockingHashtable::putIfMatch() {
 // TODO: Implement putIfMatch
 return nullptr;
}

return NonBlockingHashtable::putIfMatch() {
 // TODO: Implement putIfMatch
 return nullptr;
}

void NonBlockingHashtable::clear() {
 // TODO: Implement clear
}

int NonBlockingHashtable::size() {
 // TODO: Implement size
 return 0;
}

bool NonBlockingHashtable::contains(void* object) {
 // TODO: Implement contains
 return false;
}

void NonBlockingHashtable::clear() {
 // TODO: Implement clear
}

int NonBlockingHashtable::size() {
 // TODO: Implement size
 return 0;
}

bool NonBlockingHashtable::contains(void* object) {
 // TODO: Implement contains
 return false;
}

bool NonBlockingHashtable::remove(void* object) {
 // TODO: Implement remove
 return false;
}

void NonBlockingHashtable::clear() {
 // TODO: Implement clear
}

int NonBlockingHashtable::size() {
 // TODO: Implement size
 return 0;
}

bool NonBlockingHashtable::remove(void* object) {
 // TODO: Implement remove
 return false;
}

bool NonBlockingHashtable::contains(void* object0) {
 // TODO: Implement contains
 return false;
}

void NonBlockingHashtable::writeObject(ObjectOutputStream objectOutputStream) {
 // TODO: Implement writeObject
}

void NonBlockingHashtable::readObject(ObjectInputStream objectInputStream) {
 // TODO: Implement readObject
}

int NonBlockingHashtable::size() {
 // TODO: Implement size
 return 0;
}

int NonBlockingHashtable::slots() {
 // TODO: Implement slots
 return 0;
}

bool NonBlockingHashtable::CAS_newkvs(Object[] objects) {
 // TODO: Implement CAS_newkvs
 return false;
}

bool NonBlockingHashtable::tableFull(int int1, int int0) {
 // TODO: Implement tableFull
 return false;
}

void NonBlockingHashtable::help_copy_impl(NonBlockingHashtable nonBlockingHashtable, Object[] objects0, bool boolean0) {
 // TODO: Implement help_copy_impl
}

void NonBlockingHashtable::copy_check_and_promote(NonBlockingHashtable nonBlockingHashtable, Object[] objects, int int1) {
 // TODO: Implement copy_check_and_promote
}

bool NonBlockingHashtable::copy_slot(NonBlockingHashtable nonBlockingHashtable, int int0, Object[] objects0, Object[] objects1) {
 // TODO: Implement copy_slot
 return false;
}

TypeV NonBlockingHashtable::setValue(TypeV object) {
 // TODO: Implement setValue
 return nullptr;
}

void* NonBlockingHashtable::unbox(void* object) {
 // TODO: Implement unbox
 return nullptr;
}

public NonBlockingHashtable::SnapshotE() {
 // TODO: Implement SnapshotE
 return nullptr;
}

void NonBlockingHashtable::remove() {
 // TODO: Implement remove
}

bool NonBlockingHashtable::hasNext() {
 // TODO: Implement hasNext
 return false;
}

public NonBlockingHashtable::SnapshotK() {
 // TODO: Implement SnapshotK
 return nullptr;
}

void NonBlockingHashtable::remove() {
 // TODO: Implement remove
}

TypeK NonBlockingHashtable::next() {
 // TODO: Implement next
 return nullptr;
}

bool NonBlockingHashtable::hasNext() {
 // TODO: Implement hasNext
 return false;
}

TypeK NonBlockingHashtable::nextElement() {
 // TODO: Implement nextElement
 return nullptr;
}

bool NonBlockingHashtable::hasMoreElements() {
 // TODO: Implement hasMoreElements
 return false;
}

public NonBlockingHashtable::SnapshotV() {
 // TODO: Implement SnapshotV
 return nullptr;
}

int NonBlockingHashtable::length() {
 // TODO: Implement length
 return 0;
}

void* NonBlockingHashtable::key(int int0) {
 // TODO: Implement key
 return nullptr;
}

bool NonBlockingHashtable::hasNext() {
 // TODO: Implement hasNext
 return false;
}

TypeV NonBlockingHashtable::next() {
 // TODO: Implement next
 return nullptr;
}

void NonBlockingHashtable::remove() {
 // TODO: Implement remove
}

TypeV NonBlockingHashtable::nextElement() {
 // TODO: Implement nextElement
 return nullptr;
}

bool NonBlockingHashtable::hasMoreElements() {
 // TODO: Implement hasMoreElements
 return false;
}

} // namespace Collections
} // namespace core
} // namespace zombie
