#include <string>
#include "com/sun/xml/bind/v2/model/nav/Navigator.h"

namespace com {
namespace sun {
namespace xml {
namespace bind {
namespace v2 {
namespace model {
namespace nav {

C Navigator::getSuperClass(C var1) {
    // TODO: Implement getSuperClass
    return nullptr;
}

T Navigator::getBaseClass(T var1, C var2) {
    // TODO: Implement getBaseClass
    return nullptr;
}

std::string Navigator::getClassName(C var1) {
    // TODO: Implement getClassName
    return "";
}

std::string Navigator::getTypeName(T var1) {
    // TODO: Implement getTypeName
    return "";
}

std::string Navigator::getClassShortName(C var1) {
    // TODO: Implement getClassShortName
    return "";
}

F Navigator::getDeclaredField(C var1, const std::string& var2) {
    // TODO: Implement getDeclaredField
    return nullptr;
}

C Navigator::getDeclaringClassForField(F var1) {
    // TODO: Implement getDeclaringClassForField
    return nullptr;
}

C Navigator::getDeclaringClassForMethod(M var1) {
    // TODO: Implement getDeclaringClassForMethod
    return nullptr;
}

T Navigator::getFieldType(F var1) {
    // TODO: Implement getFieldType
    return nullptr;
}

std::string Navigator::getFieldName(F var1) {
    // TODO: Implement getFieldName
    return "";
}

std::string Navigator::getMethodName(M var1) {
    // TODO: Implement getMethodName
    return "";
}

T Navigator::getReturnType(M var1) {
    // TODO: Implement getReturnType
    return nullptr;
}

bool Navigator::isStaticMethod(M var1) {
    // TODO: Implement isStaticMethod
    return false;
}

bool Navigator::isSubClassOf(T var1, T var2) {
    // TODO: Implement isSubClassOf
    return false;
}

T Navigator::ref(Class var1) {
    // TODO: Implement ref
    return nullptr;
}

T Navigator::use(C var1) {
    // TODO: Implement use
    return nullptr;
}

C Navigator::asDecl(T var1) {
    // TODO: Implement asDecl
    return nullptr;
}

C Navigator::asDecl(Class var1) {
    // TODO: Implement asDecl
    return nullptr;
}

bool Navigator::isArray(T var1) {
    // TODO: Implement isArray
    return false;
}

bool Navigator::isArrayButNotByteArray(T var1) {
    // TODO: Implement isArrayButNotByteArray
    return false;
}

T Navigator::getComponentType(T var1) {
    // TODO: Implement getComponentType
    return nullptr;
}

T Navigator::getTypeArgument(T var1, int var2) {
    // TODO: Implement getTypeArgument
    return nullptr;
}

bool Navigator::isParameterizedType(T var1) {
    // TODO: Implement isParameterizedType
    return false;
}

bool Navigator::isPrimitive(T var1) {
    // TODO: Implement isPrimitive
    return false;
}

T Navigator::getPrimitive(Class var1) {
    // TODO: Implement getPrimitive
    return nullptr;
}

Location Navigator::getClassLocation(C var1) {
    // TODO: Implement getClassLocation
    return nullptr;
}

Location Navigator::getFieldLocation(F var1) {
    // TODO: Implement getFieldLocation
    return nullptr;
}

Location Navigator::getMethodLocation(M var1) {
    // TODO: Implement getMethodLocation
    return nullptr;
}

bool Navigator::hasDefaultConstructor(C var1) {
    // TODO: Implement hasDefaultConstructor
    return false;
}

bool Navigator::isStaticField(F var1) {
    // TODO: Implement isStaticField
    return false;
}

bool Navigator::isPublicMethod(M var1) {
    // TODO: Implement isPublicMethod
    return false;
}

bool Navigator::isFinalMethod(M var1) {
    // TODO: Implement isFinalMethod
    return false;
}

bool Navigator::isPublicField(F var1) {
    // TODO: Implement isPublicField
    return false;
}

bool Navigator::isEnum(C var1) {
    // TODO: Implement isEnum
    return false;
}

bool Navigator::isAbstract(C var1) {
    // TODO: Implement isAbstract
    return false;
}

bool Navigator::isFinal(C var1) {
    // TODO: Implement isFinal
    return false;
}

T Navigator::getVoidType() {
    // TODO: Implement getVoidType
    return nullptr;
}

std::string Navigator::getPackageName(C var1) {
    // TODO: Implement getPackageName
    return "";
}

C Navigator::loadObjectFactory(C var1, const std::string& var2) {
    // TODO: Implement loadObjectFactory
    return nullptr;
}

bool Navigator::isBridgeMethod(M var1) {
    // TODO: Implement isBridgeMethod
    return false;
}

bool Navigator::isOverriding(M var1, C var2) {
    // TODO: Implement isOverriding
    return false;
}

bool Navigator::isInterface(C var1) {
    // TODO: Implement isInterface
    return false;
}

bool Navigator::isTransient(F var1) {
    // TODO: Implement isTransient
    return false;
}

bool Navigator::isInnerClass(C var1) {
    // TODO: Implement isInnerClass
    return false;
}

bool Navigator::isSameType(T var1, T var2) {
    // TODO: Implement isSameType
    return false;
}

} // namespace nav
} // namespace model
} // namespace v2
} // namespace bind
} // namespace xml
} // namespace sun
} // namespace com
