#include <string>
#include <unordered_map>
#include "zombie\core\Collections/NonBlockingHashMap.h"

namespace zombie {
namespace core {
namespace Collections {

long NonBlockingHashMap::rawIndex(Object[] var0, int var1) {
    // TODO: Implement rawIndex
    return 0;
}

bool NonBlockingHashMap::CAS_kvs(Object[] var1, Object[] var2) {
    // TODO: Implement CAS_kvs
    return false;
}

int NonBlockingHashMap::hash(void* var0) {
    // TODO: Implement hash
    return 0;
}

CHM NonBlockingHashMap::chm(Object[] var0) {
    // TODO: Implement chm
    return nullptr;
}

int NonBlockingHashMap::len(Object[] var0) {
    // TODO: Implement len
    return 0;
}

void* NonBlockingHashMap::key(Object[] var0, int var1) {
    // TODO: Implement key
    return nullptr;
}

void* NonBlockingHashMap::val(Object[] var0, int var1) {
    // TODO: Implement val
    return nullptr;
}

bool NonBlockingHashMap::CAS_key(Object[] var0, int var1, void* var2, void* var3) {
    // TODO: Implement CAS_key
    return false;
}

bool NonBlockingHashMap::CAS_val(Object[] var0, int var1, void* var2, void* var3) {
    // TODO: Implement CAS_val
    return false;
}

void NonBlockingHashMap::print() {
    // TODO: Implement print
}

void NonBlockingHashMap::print(Object[] var1) {
    // TODO: Implement print
}

void NonBlockingHashMap::print2(Object[] var1) {
    // TODO: Implement print2
}

long NonBlockingHashMap::reprobes() {
    // TODO: Implement reprobes
    return 0;
}

int NonBlockingHashMap::reprobe_limit(int var0) {
    // TODO: Implement reprobe_limit
    return 0;
}

public NonBlockingHashMap::NonBlockingHashMap() {
    // TODO: Implement NonBlockingHashMap
    return nullptr;
}

public NonBlockingHashMap::NonBlockingHashMap(int var1) {
    // TODO: Implement NonBlockingHashMap
    return nullptr;
}

void NonBlockingHashMap::initialize(int var1) {
    // TODO: Implement initialize
}

void NonBlockingHashMap::initialize() {
    // TODO: Implement initialize
}

int NonBlockingHashMap::size() {
    // TODO: Implement size
    return 0;
}

return NonBlockingHashMap::chm() {
    // TODO: Implement chm
    return nullptr;
}

bool NonBlockingHashMap::isEmpty() {
    // TODO: Implement isEmpty
    return false;
}

bool NonBlockingHashMap::containsKey(void* var1) {
    // TODO: Implement containsKey
    return false;
}

bool NonBlockingHashMap::contains(void* var1) {
    // TODO: Implement contains
    return false;
}

TypeV NonBlockingHashMap::put(TypeK var1, TypeV var2) {
    // TODO: Implement put
    return nullptr;
}

TypeV NonBlockingHashMap::putIfAbsent(TypeK var1, TypeV var2) {
    // TODO: Implement putIfAbsent
    return nullptr;
}

TypeV NonBlockingHashMap::remove(void* var1) {
    // TODO: Implement remove
    return nullptr;
}

bool NonBlockingHashMap::remove(void* var1, void* var2) {
    // TODO: Implement remove
    return false;
}

TypeV NonBlockingHashMap::replace(TypeK var1, TypeV var2) {
    // TODO: Implement replace
    return nullptr;
}

bool NonBlockingHashMap::replace(TypeK var1, TypeV var2, TypeV var3) {
    // TODO: Implement replace
    return false;
}

TypeV NonBlockingHashMap::putIfMatch(void* var1, void* var2, void* var3) {
    // TODO: Implement putIfMatch
    return nullptr;
}

void NonBlockingHashMap::putAll(Map<? extends, ? extends) {
    // TODO: Implement putAll
}

void NonBlockingHashMap::clear() {
    // TODO: Implement clear
}

bool NonBlockingHashMap::containsValue(void* var1) {
    // TODO: Implement containsValue
    return false;
}

void NonBlockingHashMap::rehash() {
    // TODO: Implement rehash
}

void* NonBlockingHashMap::clone() {
    // TODO: Implement clone
    return nullptr;
}

std::string NonBlockingHashMap::toString() {
    // TODO: Implement toString
    return "";
}

bool NonBlockingHashMap::keyeq(void* var0, void* var1, int[] var2, int var3, int var4) {
    // TODO: Implement keyeq
    return false;
}

TypeV NonBlockingHashMap::get(void* var1) {
    // TODO: Implement get
    return nullptr;
}

void* NonBlockingHashMap::get_impl(NonBlockingHashMap var0, Object[] var1, void* var2, int var3) {
    // TODO: Implement get_impl
    return nullptr;
}

return NonBlockingHashMap::get_impl() {
    // TODO: Implement get_impl
    return nullptr;
}

void* NonBlockingHashMap::putIfMatch(NonBlockingHashMap var0, Object[] var1, void* var2, void* var3, void* var4) {
    // TODO: Implement putIfMatch
    return nullptr;
}

return NonBlockingHashMap::putIfMatch() {
    // TODO: Implement putIfMatch
    return nullptr;
}

return NonBlockingHashMap::putIfMatch() {
    // TODO: Implement putIfMatch
    return nullptr;
}

return NonBlockingHashMap::putIfMatch() {
    // TODO: Implement putIfMatch
    return nullptr;
}

void NonBlockingHashMap::writeObject(ObjectOutputStream var1) {
    // TODO: Implement writeObject
}

void NonBlockingHashMap::readObject(ObjectInputStream var1) {
    // TODO: Implement readObject
}

} // namespace Collections
} // namespace core
} // namespace zombie
